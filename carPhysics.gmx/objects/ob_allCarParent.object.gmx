<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>ob_allParent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//a lot of vars
///DOES CAR HAVE DRIVER related to loop
hasDriver=false;
//how far down accel tire is 
accelBalance=3;
//max turn angle
maxTurn=60;
trueMaxTurn=60;
//if dead or naw
dead=false;
//weaponsvars
zweapon=false;
xweapon=false;
ztrueRotation=0;
xtrueRotation=0;
//player or ai
player=false;


angleDampLow=4;
angleDamp=11;

turnGripCounter=0;
turnGrip=0;
turnGripMultiplier=0;
asleep=false;
engineUse=0;
//engine max + 40 is die
engineMax=120;
velocity=12;
targetVelocity=280;
turnDirection="none";
tireGrip=60;
oldRotation=0;
speedLimit=8;
trueSpeedLimit=8;
//5
accelHorsePower=trueSpeedLimit+2;
engine=true; 
control=true;
threshholdx=4;
threshholdy=2;
collide=false;
oldphy_speed_x=0;
oldphy_speed_y=0;
deadSprite=sp_truck_dead;
motorcycle=false;
falling=false;


//jump start
phy_speed_y=-1*(speedLimit);
theTire= instance_create(x,y-sprite_height/4, ob_tire);
physics_joint_revolute_create(id,theTire,theTire.x,theTire.y,0,0,0,0,0,0,false);
theTire.depth=-1000;
/*
deadWeight=instance_create(x,y+sprite_height/4,ob_junk);
physics_joint_revolute_create(id,deadWeight,deadWeight.x,deadWeight.y,0,0,0,0,0,0,false);
deadWeight.depth=-1000;
*/
theMarker=instance_create(x,y+sprite_height/4,ob_marker);
theMarker.depth=-1000000;


//scrapes
scrapeParticleSystem=part_system_create();
sParticle=part_type_create();
part_type_shape(sParticle,pt_shape_spark);
part_type_scale(sParticle,1,1);
part_type_size(sParticle,0.1,0.1,-.001,0);
part_type_color2(sParticle,make_color_rgb(255, 255, 102),make_color_rgb(255, 0, 0));
part_type_alpha1(sParticle,1);
part_type_speed(sParticle,2,3,0,0);
part_type_direction(sParticle,0,359,0,0);
//part_type_gravity(sParticle,0.02,90);
part_type_orientation(sParticle,0,359,10,0,true);
part_type_life(sParticle,100,150);
part_type_blend(sParticle,true);
scrape_emitter = part_emitter_create(scrapeParticleSystem);

//fire
fireParticleSystem=part_system_create();
fireParticle=part_type_create();
part_type_shape(fireParticle,pt_shape_sphere);
part_type_scale(fireParticle,1,1);
part_type_size(fireParticle,0.3,0.6,-.001,0.20);
part_type_color2(fireParticle,make_color_rgb(255, 255, 102),make_color_rgb(255, 0, 0));
part_type_alpha1(fireParticle,0.2);
part_type_speed(fireParticle,0.3,1,0,0);
part_type_direction(fireParticle,0,359,0,0);
//part_type_gravity(sParticle,0.02,90);
part_type_orientation(fireParticle,0,359,10,0,true);
part_type_life(fireParticle,100,150);
part_type_blend(fireParticle,true);
fire_emitter = part_emitter_create(fireParticleSystem);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
//phy_speed_y=0;
phy_position_y+=global.speed;
theTire.phy_position_y+=global.speed;
//velocity=100;

if(speedLimit&gt;trueSpeedLimit){
speedLimit-=0.15;
}
if(velocity&gt;targetVelocity){
velocity-=20;
}
if(velocity&lt;targetVelocity){
velocity+=20;
}
if(maxTurn&lt;trueMaxTurn){
maxTurn+=2;
}

//phy_position_y=phy_position_yprevious;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>





//MAX TURN
clamp(theTire.trueRotation,-maxTurn,maxTurn);
/////GUN ROTATION DOC
//
//the angle up is 0 degress to the right is negative to left is positive
//
if(zweapon=true){
//clamp(ztrueRotation,10,170);
zgun.x=x+(dcos(image_angle+90)*(sprite_height/3))-(dsin(image_angle+90)*(sprite_width/2))
zgun.y=y-(dsin(image_angle+90)*(sprite_height/3))-(dcos(image_angle+90)*(sprite_width/2))

zgun.image_angle=ztrueRotation +image_angle;

}
if(xweapon=true){
//clamp(xtrueRotation,10,170);
xgun.x=x+(dcos(image_angle+90)*(sprite_height/3))+(dsin(image_angle+90)*(sprite_width/2))
xgun.y=y-(dsin(image_angle+90)*(sprite_height/3))+(dcos(image_angle+90)*(sprite_width/2))

xgun.image_angle=xtrueRotation +image_angle;

}



control=true;





///driver stuff
if(hasDriver==true){
driver.phy_position_x=phy_position_x;
driver.phy_position_y=phy_position_y;
if(driver.dead==true){
control=false;
dead=true;
}
driver.phy_rotation=phy_rotation;


}
//slow turns back into action

velocity=clamp((power(phy_speed,4)/power(speedLimit,4))*targetVelocity,
targetVelocity/1.5,
targetVelocity);





//ai sleep
if(asleep=true){
control=false;
}
//final solution
if(phy_angular_damping&lt;angleDamp){
phy_angular_damping+=0.2;

}
if(phy_angular_damping&gt;angleDamp){
phy_angular_damping-=5;

}





//turn GRIPING

if(turnGripCounter&gt;0){
turnGripCounter--;
if(turnGripCounter&gt;20){
turnGripCounter--;

}

}
turnGrip=turnGripCounter*turnGripMultiplier;

//ENGINE 
if(engine==false){
control=false;
dead=true;
}
if(engineUse&gt;0){
engineUse--;
}
if(engineUse&gt;engineMax+40&amp;&amp;engine==true){
engine=false;
audio_play_sound(snd_burnout,9,false);
}
if(engineUse&gt;engineMax/2){
if(random(12)&lt;4){
instance_create(x+random(sprite_width)-sprite_width/2,y+sprite_height/4, ob_blackSmoke);
}


}


//FAAALLLLLIINNNNNNG
if(falling==true){
//phy_speed_x=phy_speed_x/1.05;
//phy_speed_y=phy_speed_y/1.05;
control=false;
if(image_index&gt;image_number-1){
dead=true;
phy_position_y+=10000;

}

}

//collision shake
if(engine==true&amp;&amp;collide==true&amp;&amp;player=true&amp;&amp;
(abs(oldphy_speed_y-phy_speed_y)&gt;=threshholdy/20||
abs(oldphy_speed_x-phy_speed_x)&gt;=threshholdx/20)){
  instance_create(x,y,ob_shake);
  audio_play_sound(snd_bump,9,false);
  //keep beat blasting
global.antiFade=global.standardVolume+10;
//prevent turing into cars
phy_angular_damping=angleDamp+60;
//tire shit
turnMax=10;
};

//collision death
if(engine==true&amp;&amp;collide==true&amp;&amp;
(abs(oldphy_speed_y-phy_speed_y)&gt;=threshholdy||
abs(oldphy_speed_x-phy_speed_x)&gt;=threshholdx)){
  effect_create_above(ef_explosion, x, y, 1, c_orange);
  engine=false;
  control=false;
  sprite_index=deadSprite;
  //BOOM
  audio_play_sound(snd_explosion,9,false);
  //keep beat blasting
global.antiFade=global.standardVolume+10;

};
//reset collide
collide=false;
//engine burn
if(engine==false){
part_emitter_region(fireParticleSystem, fire_emitter, x-3, x+3, y-3, y+3, ps_shape_ellipse, ps_distr_gaussian);
part_emitter_burst(fireParticleSystem,fire_emitter,fireParticle,1);
}


//return tire
if(theTire.trueRotation&gt;0){
theTire.trueRotation-=theTire.trueRotation/10;
}
if(theTire.trueRotation&lt;0){
theTire.trueRotation-=theTire.trueRotation/10;
}



//get tire
theTire.phy_rotation=theTire.trueRotation +phy_rotation;


//SLOW DOWN
//sqrt(sqr(phy_speed_y)+sqr(phy_speed_x))
if(phy_speed&gt;speedLimit){


phy_speed_x=phy_speed_x/1.2;
phy_speed_y=phy_speed_y/1.2;
if(phy_speed&gt;speedLimit+speedLimit/2){


phy_speed_x=phy_speed_x/4;
phy_speed_y=phy_speed_y/4;


}

}


/////////////ACCELERATION
if(control==true){
//mabye being in math isnt so bad.
//just normal displacemtn times percent of cos or sin to see how far up or down

physics_apply_force(x+(dcos(image_angle+90)*(sprite_height/accelBalance)),
y-(dsin(image_angle+90)*(sprite_height/accelBalance)),
(dcos(theTire.image_angle+90)*velocity/1.2),
 (dsin(theTire.image_angle+90)*velocity/1.2)*-1);
 
 physics_apply_force(x+(dcos(image_angle+90)*(sprite_height/accelBalance)),
y-(dsin(image_angle+90)*(sprite_height/accelBalance)),
(dcos(image_angle+90)*velocity/2),
 (dsin(image_angle+90)*velocity/2)*-1);
}



//theTire.

theMarker.x=x+(dcos(image_angle+90)*(sprite_height/3));
theMarker.y=y-(dsin(image_angle+90)*(sprite_height/3));


//which directon
if(phy_speed_x&gt;0){
xfricitionDirection=1;
}
else{
xfricitionDirection=-1;
}
if(phy_speed_y&gt;0){
yfricitionDirection=1;
}
else{
yfricitionDirection=-1;
}


//lets try this again
/*
if(control==true){

//mabye being in math isnt so bad.
//abs to deviation
physics_apply_force(x+(dcos(image_angle+90)*(sprite_height/3)),
y-(dsin(image_angle+90)*(sprite_height/3)),
phy_speed_x*-tireGrip,
 phy_speed_y*-tireGrip
 );
}
*/

//ok future fam, look up find angle between vectors and always remember lengthdir_x
//angle between to find variation, use -phy_speed_x and y becasue lazy
if(phy_speed!=0&amp;&amp;(dot_product(lengthdir_x(1,image_angle),
lengthdir_y(1,image_angle),
phy_speed_x,phy_speed_y)/phy_speed)&gt;-1&amp;&amp;
(dot_product(lengthdir_x(1,image_angle),
lengthdir_y(1,image_angle),
phy_speed_x,phy_speed_y)/phy_speed)&lt;1)
{
//TRY CLAMPING IF SHIT HAPPENS AGAIN
newAngle=darccos(dot_product(lengthdir_x(1,image_angle),
lengthdir_y(1,image_angle),
phy_speed_x,phy_speed_y)/phy_speed);
}
else{newAngle=90}




if(control==true){
//mabye being in math isnt so bad.
//abs to deviation
physics_apply_force(x-(dcos(image_angle+90)*(sprite_height/3)),
y+(dsin(image_angle+90)*(sprite_height/3)),
abs(dcos(newAngle))*-phy_speed_x*tireGrip,
abs(dcos(newAngle))*-phy_speed_y*tireGrip
 );
}
velocity+=abs(dcos(newAngle))*tireGrip;
//phy_speed_x*-tireGrip*turnGrip,
/// phy_speed_y*-tireGrip*turnGrip

//(dcos(image_angle)*newMagnitude)*tireGrip*xfricitionDirection,
// (dsin(image_angle)*newMagnitude)*tireGrip*yfricitionDirection

//-phy_speed_x*tireGrip*dcos(newAngle),
//-phy_speed_y*tireGrip*dcos(newAngle)

//abs(dsin(theTire.image_angle+90))*
// abs(dcos(theTire.image_angle+90))*
//abs(dsin(image_angle+90))*
//abs(dcos(image_angle+90))*

//tire grip real
/*
if(theTire.phy_rotation&lt;-20){

physics_apply_force(x, y-sprite_height/4,(dcos(theTire.image_angle)*tireGrip)*-1, (dsin(theTire.image_angle)*tireGrip));
}
if(theTire.phy_rotation&gt;20){

physics_apply_force(x, y-sprite_height/4,(dcos(theTire.image_angle)*tireGrip), (dsin(theTire.image_angle)*tireGrip)*-1);

}
//back tire anti driving side ways
if(phy_rotation&lt;-70){

physics_apply_force(x, y+sprite_height/4,(dcos(image_angle)*tireGrip)*-4, (dsin(image_angle)*tireGrip)*4);
}
if(phy_rotation&gt;70){

physics_apply_force(x, y+sprite_height/4,(dcos(image_angle)*tireGrip)*4, (dsin(image_angle)*tireGrip)*-4);
}


*/
//checks to draw sutff and stutter - 1 so it draws tires but doesnt bunch em up
if(falling==false&amp;&amp;asleep==false&amp;&amp;global.stutter-1&lt;0){
///DUST CREATION

if(random(12)&lt;3){
instance_create(x+random(sprite_width)-sprite_width/2,y+sprite_height/4, ob_smokeBloom);
}

//tire


if(motorcycle==false){

instance_create(
x-(dcos(image_angle+90)*(sprite_height/3))-(dsin(image_angle+90)*(sprite_width/3)),
y+(dsin(image_angle+90)*(sprite_height/3))-(dcos(image_angle+90)*(sprite_width/3))
, ob_tireTrack);

instance_create(
x-(dcos(image_angle+90)*(sprite_height/3))+(dsin(image_angle+90)*(sprite_width/3)),
y+(dsin(image_angle+90)*(sprite_height/3))+(dcos(image_angle+90)*(sprite_width/3))
, ob_tireTrack);
//instance_create(x-sprite_width/2,y+sprite_height/4, ob_tireTrack);
}
else{

instance_create(
x-(dcos(image_angle+90)*(sprite_height/3)),
y+(dsin(image_angle+90)*(sprite_height/3))
, ob_tireTrack);
}



}

//phy_speed_y=-20;
//phy_angular_velocity=0;

/*
if(oldTireRotation-theTire.trueRotation&gt;0){

physics_apply_force(x, y-sprite_height/4,(dcos(theTire.image_angle)*tireGrip)*-1, (dsin(theTire.image_angle)*tireGrip));
//physics_apply_force(x, y-sprite_width/4, -tireGrip, 0);
}
if(oldTireRotation-theTire.trueRotation&lt;-0){

physics_apply_force(x, y-sprite_height/4,(dcos(theTire.image_angle)*tireGrip), (dsin(theTire.image_angle)*tireGrip)*-1);
//physics_apply_force(x, y-sprite_width/4, tireGrip, 0);
}
*/
//keep track of tire rotation
oldRotation=image_angle;



oldphy_speed_x=phy_speed_x;
oldphy_speed_y=phy_speed_y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="ob_smallBullet">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>part_emitter_burst(scrapeParticleSystem,scrape_emitter,sParticle,3);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="ob_allCarParent">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if(other.x&gt;x){
part_emitter_region(scrapeParticleSystem, scrape_emitter, x+sprite_width/2, x+sprite_width/2, y-sprite_height/2, y+sprite_height/2, ps_shape_ellipse, ps_distr_gaussian);
}
if(other.x&lt;x){
part_emitter_region(scrapeParticleSystem, scrape_emitter, x-sprite_width/2, x-sprite_width/2, y-sprite_height/2, y+sprite_height/2, ps_shape_ellipse, ps_distr_gaussian);
}
if(other.y-sprite_width/2&gt;y+sprite_width/2){
part_emitter_region(scrapeParticleSystem, scrape_emitter, x+sprite_width/2, x-sprite_width/2, y+sprite_height/2, y+sprite_height/2, ps_shape_ellipse, ps_distr_gaussian);
}
if(other.y+sprite_width/2&lt;y-sprite_width/2){
part_emitter_region(scrapeParticleSystem, scrape_emitter, x+sprite_width/2, x-sprite_width/2, y-sprite_height/2, y-sprite_height/2, ps_shape_ellipse, ps_distr_gaussian);
}


//prevent turning into cars
//phy_angular_damping=angleDampLow;


part_emitter_burst(scrapeParticleSystem,scrape_emitter,sParticle,3);
collide=true;
//collision death
/*
if(
abs(other.phy_speed_x-phy_speed_x)&gt;=threshholdx
||
abs(other.phy_speed_y-phy_speed_y)&gt;=threshholdy
&amp;&amp;
engine==true
){
effect_create_above(ef_explosion, x, y, 1, c_orange);
engine=false;
}


show_debug_message("other");
show_debug_message(other.phy_speed_y);
show_debug_message("this");
show_debug_message(phy_speed_y);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="ob_allParent">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>

collide=true;
/*
if(abs(other.phy_speed_x-phy_speed_x)&gt;=threshholdx||abs(other.phy_speed_y-phy_speed_y)&gt;=threshholdy)&amp;&amp;engine==true{
effect_create_above(ef_explosion, x, y, 1, c_orange);
engine=false;
}
show_debug_message("other");
show_debug_message(other.phy_speed_y);
show_debug_message("this");
show_debug_message(phy_speed_y);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>-1</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>1</PhysicsObjectShape>
  <PhysicsObjectDensity>0</PhysicsObjectDensity>
  <PhysicsObjectRestitution>1</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>9.99999974737875E-5</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
